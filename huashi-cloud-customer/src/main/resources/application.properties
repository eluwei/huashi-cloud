spring.application.name=huashi-cloud-customer
server.port=18002
spring.profiles.active=native
eureka.client.serviceUrl.defaultZone=${cloud.register.domain}
logging.path=/opt/cloudlog
logging.file=/opt/cloudlog/${spring.application.name}.log
logging.level.root=info

spring.datasource.url = ${spring.datasource.url}
spring.datasource.username = ${spring.datasource.username}
spring.datasource.password = ${spring.datasource.password}
spring.datasource.poolName = ${spring.datasource.poolName}
spring.datasource.maximumPoolSize = ${spring.datasource.maximumPoolSize}
spring.datasource.minimumIdle = ${spring.datasource.minimumIdle}
spring.datasource.maxLifetime =${spring.datasource.maxLifetime}
spring.datasource.connectionTimeout = ${spring.datasource.connectionTimeout}
spring.datasource.idleTimeout = ${spring.datasource.idleTimeout}
spring.datasource.pool-prepared-statements = ${spring.datasource.pool-prepared-statements}
spring.datasource.max-open-prepared-statements = ${spring.datasource.max-open-prepared-statements}



# Spring JPA
#spring.jpa.databasePlatform=org.hibernate.dialect.MySQLDialect
#ddl-auto:create----每次运行该程序，没有表格会新建表格，表内有数据会清空
#ddl-auto:create-drop----每次程序结束的时候会清空表
#ddl-auto:update----每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新
#ddl-auto:validate----运行程序会校验数据与数据库的字段类型是否相同，不同会报错
spring.jpa.hibernate.ddl-auto=update
spring.jpa.generate-ddl = true
spring.jpa.show-sql = false
spring.jpa.properties.hibernate.format_sql = true
#防止hibernate的映射导致不是驼峰，与数据库的字段不匹配
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


#七牛
#填写自己的参数
qiniu.accesskey=aTLmh_-BkzEZuRP12TJWY4hIDEzrxoxERcfTKiml
qiniu.secretkey=21C2hpFlTgSttGIBgeEKNZtngSeM9WywrELweSA1
qiniu.bucket=huashi-picture
qiniu.cdns=pa0033s0h.bkt.clouddn.com

#redis配置
spring.redis.database=0
spring.redis.host=47.96.108.175
spring.redis.port=6379
spring.redis.password=jiabo
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=-1
spring.redis.pool.max-idle=8
spring.redis.pool.min-idle=0
spring.redis.timeout=0

#################################  传统网关配置  start ################
# 所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件
# 中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由

#spring网关多路由配置一个实体
#zuul.routes.huashi-cloud-customer.path=/huashi-cloud-customer/**
#zuul.routes.huashi-cloud-customer.url=http://localhost:18002/

#spring网关多路由配置多个实体
#zuul.routes.huashi-cloud-customer.path=/huashi-cloud-customer/**
#zuul.routes.huashi-cloud-customer.serviceId=huashi-cloud-customer
#ribbon.eureka.enabled=false
#huashi-cloud-customer.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/
#################################  传统网关配置  end ################

#################################  服务路由配置  start ################
#服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，
# 实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为serviceId去指定具体的服务实例地址，
# 只需要通过一组zuul.routes.<route>.path与zuul.routes.<route>.serviceId参数对的方式配置即可。
zuul.routes.huashi-cloud-customer.path=/huashi-cloud-customer/**
zuul.routes.huashi-cloud-customer.serviceId=huashi-cloud-customer
#应该是hystrix也有超时限制，hystrix的默认超时时间是1秒，修改其默认超时时间
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=10000